"""Enhanced logger module with improved type hints and async support.

This module provides structured logging capabilities with PostgreSQL L1 memory
integration following the COS memory architecture.

Key Features:
- Rich console logging with color support
- Async-first design with sync compatibility
- PostgreSQL event storage integration
- Type-safe interfaces with full type hints
- Mem0 integration placeholder for future enhancements
"""

from __future__ import annotations

import asyncio
import concurrent.futures
import logging
import uuid
from datetime import UTC, datetime
from typing import Any, TypedDict

from rich.logging import RichHandler

# Configure rich logging handler
logging.basicConfig(level="INFO", format="%(message)s", datefmt="[%X]", handlers=[RichHandler()])

# Main logger instance
logger: logging.Logger = logging.getLogger("cos")

# Placeholder for mem0 integration
mem: Any | None = None


class LogEventResponse(TypedDict, total=False):
    """Type definition for log event response."""

    status: str
    id: str
    base_log_id: str | None
    event_log_id: str | None
    memo: str | None
    data: str | dict[str, Any]
    error: str | None


def get_logger(name: str) -> logging.Logger:
    """Get a logger instance for the given module name.

    Args:
    ----
        name: The module name (typically __name__)

    Returns:
    -------
        A logger instance configured for COS with the namespace cos.<name>

    """
    return logging.getLogger(f"cos.{name}")


def log_event(
    source: str,
    data: str | dict[str, Any],
    tags: list[str] | None = None,
    key: str | None = None,
    memo: str | None = None,
) -> LogEventResponse:
    """Log a structured memory event to PostgreSQL L1 memory.

    This function handles both sync and async contexts automatically,
    ensuring compatibility across different execution environments.

    Args:
    ----
        source: The module logging the event (e.g., 'pem', 'cc', 'cursor')
        data: The core payload (prompt, result, etc.)
        tags: Optional tags to categorize memory
        key: Optional custom key; else autogenerated
        memo: Optional human-readable description

    Returns:
    -------
        Response dictionary with database IDs and status

    """
    try:
        # Try to get current event loop
        asyncio.get_running_loop()
        # If we're in an event loop, we can't use asyncio.run()
        # Create a task instead using a thread pool

        def run_in_thread() -> LogEventResponse:
            """Run async function in a new event loop within a thread."""
            new_loop = asyncio.new_event_loop()
            asyncio.set_event_loop(new_loop)
            try:
                return new_loop.run_until_complete(log_event_async(source, data, tags, key, memo))
            finally:
                new_loop.close()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(run_in_thread)
            return future.result(timeout=10)  # 10 second timeout

    except RuntimeError:
        # No event loop running, safe to use asyncio.run()
        return asyncio.run(log_event_async(source, data, tags, key, memo))


async def log_event_async(
    source: str,
    data: str | dict[str, Any],
    tags: list[str] | None = None,
    key: str | None = None,
    memo: str | None = None,
) -> LogEventResponse:
    """Async version of log_event for use in async contexts.

    This is the core implementation that writes to PostgreSQL.

    Args:
    ----
        source: The module logging the event (e.g., 'pem', 'cc', 'cursor')
        data: The core payload (prompt, result, etc.)
        tags: Optional tags to categorize memory
        key: Optional custom key; else autogenerated
        memo: Optional human-readable description

    Returns:
    -------
        Response dictionary with database IDs and status

    """
    from src.backend.cc.mem0_models import BaseLog, EventLog
    from src.db.connection import get_async_session_maker

    log_id = key or f"log-{source}-{uuid.uuid4().hex[:8]}"

    # Create structured payload
    payload: dict[str, Any] = {
        "source": source,
        "data": data,
        "tags": tags or [],
        "timestamp": datetime.now(UTC).isoformat(),
        "log_id": log_id,
    }

    # Only include memo if provided
    if memo is not None:
        payload["memo"] = memo

    # Return stub response immediately if memo is None
    if memo is None:
        return LogEventResponse(
            status="mem0_stub",
            id=log_id,
            memo=None,
            data=data,
        )

    try:
        # Get database session
        async_session_maker = get_async_session_maker()
        async with async_session_maker() as session:
            # Create BaseLog entry
            base_log = BaseLog(
                level="INFO",
                message=f"[{source}] {memo or 'Event logged'}",
                payload=payload,
            )
            session.add(base_log)
            await session.flush()  # Get the ID

            # Create EventLog entry linked to BaseLog
            event_log = EventLog(
                base_log_id=base_log.id,
                event_type=f"{source}.event",
                event_data={
                    "data": data,
                    "tags": tags or [],
                    "memo": memo,
                    "log_id": log_id,
                },
            )
            session.add(event_log)

            # Commit the transaction
            await session.commit()

            return LogEventResponse(
                status="success",
                id=log_id,
                base_log_id=str(base_log.id),
                event_log_id=str(event_log.id),
                memo=memo,
                data=data,
            )

    except Exception as e:
        logger.error(f"Failed to write log event to database: {e}")
        # Return fallback response on database error
        return LogEventResponse(
            status="fallback",
            id=log_id,
            error=str(e),
            memo=memo,
            data=data,
        )


# Optional usage example
def _demo() -> LogEventResponse:
    """Demonstrate log_event usage with sample data.

    Returns
    -------
        Example log event response

    """
    return log_event(
        source="pem",
        data={"prompt": "What is quantum authorship?", "output": "..."},
        tags=["prompt", "test"],
        memo="Initial PEM prompt test",
    )


if __name__ == "__main__":
    logger.info(f"Demo log event result: {_demo()}")
