import logging
import uuid
from datetime import UTC, datetime
from typing import Any

from rich.logging import RichHandler

logging.basicConfig(level="INFO", format="%(message)s", datefmt="[%X]", handlers=[RichHandler()])
logger = logging.getLogger("cos")

# Placeholder for mem0 integration
mem = None


def get_logger(name: str) -> logging.Logger:
    """Get a logger instance for the given module name.

    Args:
    ----
        name (str): The module name (typically __name__)

    Returns:
    -------
        logging.Logger: A logger instance configured for COS

    """
    return logging.getLogger(f"cos.{name}")


def log_event(
    source: str,
    data: str | dict[str, Any],
    tags: list[str] | None = None,
    key: str | None = None,
    memo: str | None = None,
) -> dict[str, Any]:
    """Log a structured memory event to PostgreSQL L1 memory.

    Args:
    ----
        source (str): The module logging the event (e.g., 'pem', 'cc', 'cursor')
        data (str|dict): The core payload (prompt, result, etc.)
        tags (list): Optional tags to categorize memory
        key (str): Optional custom key; else autogenerated
        memo (str): Optional human-readable description

    Returns:
    -------
        dict: response with database IDs and status

    """
    import asyncio

    try:
        # Try to get current event loop
        asyncio.get_running_loop()
        # If we're in an event loop, we can't use asyncio.run()
        # Create a task instead
        import concurrent.futures

        def run_in_thread() -> dict[str, Any]:
            new_loop = asyncio.new_event_loop()
            asyncio.set_event_loop(new_loop)
            try:
                return new_loop.run_until_complete(log_event_async(source, data, tags, key, memo))
            finally:
                new_loop.close()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(run_in_thread)
            return future.result(timeout=10)  # 10 second timeout

    except RuntimeError:
        # No event loop running, safe to use asyncio.run()
        return asyncio.run(log_event_async(source, data, tags, key, memo))


async def log_event_async(
    source: str,
    data: str | dict[str, Any],
    tags: list[str] | None = None,
    key: str | None = None,
    memo: str | None = None,
) -> dict[str, Any]:
    """Async version of log_event for use in async contexts.

    This is the core implementation that writes to PostgreSQL.
    """
    from src.backend.cc.mem0_models import BaseLog, EventLog
    from src.db.connection import get_async_session_maker

    log_id = key or f"log-{source}-{uuid.uuid4().hex[:8]}"

    # Create structured payload
    payload = {
        "source": source,
        "data": data,
        "tags": tags or [],
        "timestamp": datetime.now(UTC).isoformat(),
        "log_id": log_id,
    }

    # Only include memo if provided
    if memo is not None:
        payload["memo"] = memo

    # Return stub response immediately if memo is None
    if memo is None:
        return {
            "status": "mem0_stub",
            "id": log_id,
            "memo": None,
            "data": data,
        }

    try:
        # Get database session
        async_session_maker = get_async_session_maker()
        async with async_session_maker() as session:  # type: ignore[attr-defined]
            # Create BaseLog entry
            base_log = BaseLog(
                level="INFO",
                message=f"[{source}] {memo or 'Event logged'}",
                payload=payload,
            )
            session.add(base_log)
            await session.flush()  # Get the ID

            # Create EventLog entry linked to BaseLog
            event_log = EventLog(
                base_log_id=base_log.id,
                event_type=f"{source}.event",
                event_data={
                    "data": data,
                    "tags": tags or [],
                    "memo": memo,
                    "log_id": log_id,
                },
            )
            session.add(event_log)

            # Commit the transaction
            await session.commit()

            return {
                "status": "success",
                "id": log_id,
                "base_log_id": str(base_log.id),
                "event_log_id": str(event_log.id),
                "memo": memo,
                "data": data,
            }

    except Exception as e:
        logger.error(f"Failed to write log event to database: {e}")
        # Return fallback response on database error
        return {
            "status": "fallback",
            "id": log_id,
            "error": str(e),
            "memo": memo,
            "data": data,
        }


# Optional usage example
def _demo() -> dict[str, Any]:
    return log_event(
        source="pem",
        data={"prompt": "What is quantum authorship?", "output": "..."},
        tags=["prompt", "test"],
        memo="Initial PEM prompt test",
    )


if __name__ == "__main__":
    logger.info(f"Demo log event result: {_demo()}")
